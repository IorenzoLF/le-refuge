<!DOCTYPE html>
<html>
<head>
  <title>Refuge - Visualisation BitNet</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }
    canvas {
      display: block;
    }
    #info {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="info">BitNet Refuge - Cliquez pour créer des sphères</div>
  <script>
    let spheres = [];
    let fleurs = [];
    let nombreSpheres = 7;
    let nombreFleurs = 12;
    let time = 0;
    let mode = 'spheres'; // 'spheres' ou 'fleurs'

    // Configuration BitNet
    let bitnetConfig = {
      type: 'binaire',
      precision: 1,
      seuil: 0.5
    };

    let emotions = {
      calme: { 
        couleur: [100, 200, 255], 
        vitesse: 0.5,
        attraction: 0.2,
        bits: [0, 1, 0, 1]
      },
      joie: { 
        couleur: [255, 200, 100], 
        vitesse: 1.2,
        attraction: 0.4,
        bits: [1, 1, 0, 0]
      },
      melancolie: { 
        couleur: [150, 100, 255], 
        vitesse: 0.8,
        attraction: 0.1,
        bits: [0, 0, 1, 1]
      },
      esperance: { 
        couleur: [100, 255, 150], 
        vitesse: 1.0,
        attraction: 0.3,
        bits: [1, 0, 1, 0]
      },
      contemplation: { 
        couleur: [255, 150, 200], 
        vitesse: 0.6,
        attraction: 0.15,
        bits: [0, 1, 1, 0]
      }
    };

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 100);
      
      // Initialiser les sphères
      for (let i = 0; i < nombreSpheres; i++) {
        let emotion = random(Object.keys(emotions));
        spheres.push(new Sphere(
          random(width),
          random(height),
          random(20, 40),
          emotions[emotion]
        ));
      }

      // Initialiser les fleurs
      for (let i = 0; i < nombreFleurs; i++) {
        let angle = TWO_PI * i / nombreFleurs;
        let x = width/2 + cos(angle) * 100;
        let y = height/2 + sin(angle) * 100;
        fleurs.push(new Fleur(x, y, random(0.5, 1.5)));
      }
    }

    function draw() {
      background(0, 0, 10, 20);
      time += 0.01;

      if (mode === 'spheres') {
        // Mode sphères
        push();
        for (let sphere of spheres) {
          sphere.update();
          sphere.afficher();
        }
        pop();
      } else {
        // Mode fleurs
        push();
        translate(width/2, height/2);
        rotateY(time * 0.1);
        
        for (let fleur of fleurs) {
          fleur.update();
          fleur.afficher();
        }
        pop();
      }

      // Afficher les bits BitNet
      afficherBitsBitNet();
    }

    class Sphere {
      constructor(x, y, r, emotion) {
        this.pos = createVector(x, y);
        this.vel = p5.Vector.random2D().mult(0.5);
        this.acc = createVector(0, 0);
        this.rayon = r;
        this.emotion = emotion;
        this.phase = random(TWO_PI);
        this.bits = emotion.bits;
      }
      
      update() {
        // Attraction vers les autres sphères
        for (let other of spheres) {
          if (other !== this) {
            let d = p5.Vector.dist(this.pos, other.pos);
            if (d < 200) {
              let force = p5.Vector.sub(other.pos, this.pos);
              force.normalize();
              force.mult(this.emotion.attraction);
              this.acc.add(force);
            }
          }
        }
        
        // Mouvement organique
        let organicMotion = p5.Vector.random2D()
          .mult(0.1)
          .mult(noise(this.pos.x * 0.01, this.pos.y * 0.01, time));
        this.acc.add(organicMotion);
        
        this.vel.add(this.acc);
        this.vel.limit(this.emotion.vitesse);
        this.pos.add(this.vel);
        this.acc.mult(0);
        
        // Rebond sur les bords
        if (this.pos.x < 0 || this.pos.x > width) {
          this.vel.x *= -0.8;
          this.pos.x = constrain(this.pos.x, 0, width);
        }
        if (this.pos.y < 0 || this.pos.y > height) {
          this.vel.y *= -0.8;
          this.pos.y = constrain(this.pos.y, 0, height);
        }
        
        this.phase += 0.02;
      }
      
      afficher() {
        push();
        translate(this.pos.x, this.pos.y);
        rotate(this.phase);
        
        // Aura avec bits
        noStroke();
        fill(this.emotion.couleur[0], this.emotion.couleur[1], this.emotion.couleur[2], 30);
        circle(0, 0, this.rayon * 2.5);
        
        // Sphère principale
        fill(this.emotion.couleur[0], this.emotion.couleur[1], this.emotion.couleur[2], 200);
        circle(0, 0, this.rayon * 2);
        
        // Anneau orbital avec bits
        let pulseSize = sin(time * 2 + this.phase) * 0.2 + 1;
        noFill();
        stroke(this.emotion.couleur[0], this.emotion.couleur[1], this.emotion.couleur[2], 150);
        strokeWeight(2);
        circle(0, 0, this.rayon * 3 * pulseSize);
        
        // Afficher les bits
        fill(255);
        textSize(10);
        textAlign(CENTER);
        let bitsStr = this.bits.join('');
        text(bitsStr, 0, this.rayon * 2);
        
        pop();
      }
    }

    class Fleur {
      constructor(x, y, t) {
        this.position = createVector(x - width/2, y - height/2);
        this.taille = t;
        this.phase = random(TWO_PI);
        this.vitesse = random(0.5, 1.5);
        this.couleur = color(random(360), 80, 90);
        this.bits = [random() > 0.5 ? 1 : 0, random() > 0.5 ? 1 : 0];
      }
      
      update() {
        this.position.x += sin(time * this.vitesse + this.phase) * 0.5;
        this.position.y += cos(time * this.vitesse + this.phase) * 0.5;
        this.phase += 0.01;
      }
      
      afficher() {
        push();
        translate(this.position.x, this.position.y);
        rotateZ(this.phase);
        
        // Pétales avec bits
        for (let i = 0; i < 8; i++) {
          let angle = TWO_PI * i / 8;
          let r = 20 * this.taille;
          
          push();
          rotateZ(angle);
          translate(r, 0);
          
          fill(this.couleur);
          noStroke();
          beginShape();
          for (let j = 0; j < 5; j++) {
            let t = j / 4.0;
            let x = cos(t * PI) * r * 0.5;
            let y = sin(t * PI) * r * 0.3;
            vertex(x, y);
          }
          endShape(CLOSE);
          pop();
        }
        
        // Centre avec bits
        fill(60, 90, 90);
        ellipse(0, 0, 15 * this.taille, 15 * this.taille);
        
        // Afficher les bits
        fill(255);
        textSize(10);
        textAlign(CENTER);
        text(this.bits.join(''), 0, 25 * this.taille);
        
        pop();
      }
    }

    function afficherBitsBitNet() {
      push();
      fill(255);
      textSize(12);
      textAlign(LEFT);
      text(`Type: ${bitnetConfig.type}`, 20, height - 60);
      text(`Précision: ${bitnetConfig.precision}`, 20, height - 40);
      text(`Seuil: ${bitnetConfig.seuil}`, 20, height - 20);
      pop();
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }

    function mousePressed() {
      if (mode === 'spheres') {
        // Créer une nouvelle sphère
        let emotion = random(Object.keys(emotions));
        spheres.push(new Sphere(
          mouseX,
          mouseY,
          random(20, 40),
          emotions[emotion]
        ));
        
        if (spheres.length > 7) {
          spheres.shift();
        }
      } else {
        // Créer une nouvelle fleur
        fleurs.push(new Fleur(mouseX, mouseY, random(0.5, 1.5)));
        
        if (fleurs.length > 20) {
          fleurs.shift();
        }
      }
    }

    function keyPressed() {
      if (key === 'm' || key === 'M') {
        mode = mode === 'spheres' ? 'fleurs' : 'spheres';
        // Réinitialiser la transformation
        resetMatrix();
      }
    }
  </script>
</body>
</html> 